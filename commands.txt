bash --version
echo $SHELL --> To see the main shell in my computer
history | less --> To see the content in an interactive way
history | wc --> To see the amount of lines, words and characterers in a file

Piping is usually used with the following tools:
    grep, awk, sed, cut

----
|
>
>>
1>
2>
1>>
2>>
<
<<

<< EndOfText
    "Commands"
EndOfText

----
Built-in functions

echo
printf
command echo
builtin echo
command -V echo
command -V df
The default is always the built-in programs
enable -n echo
enable -n
enable echo
help echo --> Help is only used with builtins
help --> To see the builtins that bash provides

----
~
{...}
${...}
$(...) --> Also `...`
$((...)) --> Also $[...]

----
echo ~
whoami
echo ~- --> The same output could be reached by echo $OLDPWD

----
echo /tmp/{one,two,three}/file.txt
echo c{a,o,u}t
echo /tmp/{1..3}/file.txt
echo {00..100}
echo {100.00}
echo {a..z}
echo {Z..A}
echo {1..30..3}
echo {a..z..2}
touch file_{01..12}{a..d}
rm file_*
echo {cat,dog,fox}
echo {cat,dog,fox}_{1..5}
head -n1 {dir1,dir2,dir3}/lorem.txt

----
a="Hello World World"
echo $a  --> This is different to "echo a"
echo ${a}
echo ${a:4}
echo ${a:1:12}
echo ${a/World/Everybody}
echo ${a//World/Everybody}
echo ${a//o/_}
echo $a:1:12  --> Everything right here is interpreted as a parameter not as a command

----
uname -r
echo "The kernel is $(uname -r)."
echo "The python version is $(python3 -V)"
echo "Result: $(python3 -c 'print("Hello from Python!")')"
echo "Result: $(python3 -c 'print("Hello from Python!")' | tr [a-z] [A-Z])"
echo "Result: `python3 -c 'print("Hello from Python!")'`"
Command substitution is often used with grep awk, and cut

----
echo $((2+2))
echo $((3-2))
echo $((3*4))
echo $((4/5))
Bash can only calculate operations using integers

----
embeddedWord="nice"
echo Hi $embeddedWord world!
echo Hi \(big\) world. The kernel is $(uname -r)
echo 'Hi \(big\) world. The kernel is $(uname -r)' --> These are the strong quotes
echo "Hi \(big\) world. The kernel is $(uname -r)" --> More flexible
echo;echo "Ni hao!";echo
echo -n "Ni hao" --> Turns out the new line

----
_var=hi
_var="hi hi"
_var=7
echo $_var
declare -r _immutable_var=14
declare -l _lowercase_var="HELLO HELLO"
_lowercase_var="NI HAO NI HAO"
declare -u _uppercase_var="hi hi"
_uppercase_var="guten morgen"
declare -p
echo $USER

----
echo $(( (3+6)*12 - (2**7)  ))
a=3
((a+=3))
((a++))
((a--))
b=$a+1 --> Bash treats this as a string
declare -i b=3 --> To declare a variable to be used as an integer
b=$b+1 --> This isn't gonna give as an error
echo $((a++))
declare -i c
declare -i e=1
declare -i f=3
n=$(echo "scale=3; $e/$f" | bc)
echo $n
echo $RANDOM
echo $(( 1 + RANDOM % 10 ))
echo $(( 1 + RANDOM % 20 ))
echo $(( 1 + RANDOM % 100 ))

----
help test
[ -d ~ ] --> It's important to add spaces to the insides of the brackets
echo $?
[ -d /bin/bash ]; echo $?
[ -d /bin ]; echo $?
[ "cat" = "dog" ]; echo $? --> The following symbols are used only by strings  >, >=, <, <= 
[ 1 = 1 ]; echo $?
[ 1 -lt 5 ]; echo $?
[ ! 1 -lt 5 ]; echo $?

----
[[  ]] --> This is called extended tests and give us extended tools not provided by regular test, say, []
[[ -d ~ && -a /bin/bash ]]; echo $?
[[ -d ~ || -a /bin/bashh ]]; echo $?
[[ -d ~ ]] && echo This runs if the statement inside of double brackets is true
ls && echo This runs if the statement inside of double brackets is true
true && echo This runs if the statement inside of double brackets is true
false && echo This runs if the statement inside of double brackets is true
[[ "cat" =~ c.* ]]; echo $?

----
echo -e "\a"
echo -e "Name\t\tNumber"; echo -e "Scott\t\t123"
echo -e "This text\nbreaks over\nthree lines"
echo -e "Ding\a"

----
echo "The results are: $(( 2 + 2 )) and $(( 3 / 1 ))"
printf "The results are: %d and %d\n" $(( 2 + 2 )) $(( 3 / 1 ))

----
