bash --version
echo $SHELL --> To see the main shell in my computer
history | less --> To see the content in an interactive way
history | wc --> To see the amount of lines, words and characterers in a file
cat commands.txt | wc -l
cat commands.txt | wc -w
cat commands.txt | wc -c

Piping is usually used with the following tools:
    grep, awk, sed, cut

Other editors that I could use --> EMACS or ED

----

What do 0,1, and 2 mean Bourne Shell?

0 --> Standard input (stdin)
1 --> Standard output (stdout)
2 --> Standart error (stderr)

----

ls > output.txt --> Truncate
ls >> output.txt --> Append

ls /notreal 1> output.txt 2> error.txt
ls /notreal 1>> output.txt 2>> error.txt

I can use too "ls /notreal 0> output.txt" but, it's a bit counterproductive, things doesn't work well here

When using ">" or ">>" the default number used on background is 1

cat < commands.txt
ls | cat

cat << EndOfText
This is
a multiline
bash command giver
EndOfText

----

Piping is used to send streams from one program to another

Redirection is used to send strems from one file to another

----
|
>
>>
1>
2>
1>>
2>>
<
<<

<< EndOfText
    "Commands"
EndOfText

----
Built-in functions

echo  --> Output something on the shell adding a jumpspace
printf  --> Output something on he shell without add a jumpspace
command echo  --> To execute external program version of a command (echo could be a built-in or an external program)
builtin echo  --> To execute the built-in program version of a command
command -V echo  --> To realize if the command is an external program or a built-in program (This is a built-in)
command -V df  --> To realize if the command is an external program or a built-in program (This is an external program)

The default is always the built-in programs

enable -n echo --> To disable the built-in form of a program as default. In this case, the external program will default to echo
enable -n  --> To see the whole list of disabled built-in commands
enable echo  --> To enable the built-in command echo as the default
help echo --> To see the manpages of a built-in command. Built-in commands have different manpages
help --> To see the builtins that bash provides

----

Bash Expansions and Substitutions:

~  --> Tilde expansion
{...}  --> Brace expansion
${...}  --> Parameter expansion
$(...)  --> Also `...`  --> Command expansion
$((...)) --> Also $[...]  --> Arithmetic expansion

----

Tilde Expansion  --> To save the user's HOME directory

echo ~  --> Too see what's user's home. It is not the "global" home
echo $HOME  --> To do exactlly the same as previous command
whoami  --> To see what's the user I'm using
echo ~- --> To see the previous directory I was in
echo $OLDPWD --> To do exactly the same as previous command

----

Brace Expansion  --> To express range of numbers or any other sequence shorter

echo /tmp/{one,two,three}/file.txt
    /tpm/one/file.txt /tpm/two/file.txt /tpm/three/file.txt

echo c{a,o,u}t
    cat cot cut

echo /tmp/{1..3}/file.txt
    /tmp/1/file.txt /tmp/2/file.txt /tmp/3/file.txt

echo {00..100}
    000 001 002 003 004 (more numbers) 097 098 099 100
    
echo {1..10}
echo {10..1}

echo {01..100}
echo {00001..10}

echo {100..00}

echo {a..z}
echo {Z..A}

echo {1..30..3}

echo {a..z..2}

touch file_{01..12}{a..d}
rm file_*

echo {cat,dog,fox}
echo {cat,dog,fox}_{1..5}

head -n1 {dir1,dir2,dir3}/lorem.txt

----
a="Hello World World"
echo $a  --> This is different to "echo a"
echo ${a}
echo ${a:4}
echo ${a:1:12}
echo ${a/World/Everybody}
echo ${a//World/Everybody}
echo ${a//o/_}
echo $a:1:12  --> Everything right here is interpreted as a parameter not as a command

----
uname -r
echo "The kernel is $(uname -r)."
echo "The python version is $(python3 -V)"
echo "Result: $(python3 -c 'print("Hello from Python!")')"
echo "Result: $(python3 -c 'print("Hello from Python!")' | tr [a-z] [A-Z])"
echo "Result: `python3 -c 'print("Hello from Python!")'`"
Command substitution is often used with grep awk, and cut

----
echo $((2+2))
echo $((3-2))
echo $((3*4))
echo $((4/5))
Bash can only calculate operations using integers

----
embeddedWord="nice"
echo Hi $embeddedWord world!
echo "Hi $embeddedWord world!"
echo Hi \(big\) world. The kernel is $(uname -r)
echo 'Hi \(big\) world. The kernel is $(uname -r)' --> These are the strong quotes
echo "Hi \(big\) world. The kernel is $(uname -r)" --> More flexible
echo;echo "Ni hao!";echo
echo -n "Ni hao" --> Turns out the new line

----
_var=hi
_var="hi hi"
_var=7
echo $_var
declare -r _immutable_var=14
declare -l _lowercase_var="HELLO HELLO"
_lowercase_var="NI HAO NI HAO"
declare -u _uppercase_var="hi hi"
_uppercase_var="guten morgen"
declare -p
echo $USER

----
echo $(( (3+6)*12 - (2**7)  ))
a=3
((a+=3))
((a++))
((a--))
b=$a+1 --> Bash treats this as a string
declare -i b=3 --> To declare a variable to be used as an integer
b=$b+1 --> This isn't gonna give as an error
echo $((a++)) --> I coudl use it here
declare -i c
declare -i e=1
declare -i f=3
n=$(echo "scale=3; $e/$f" | bc)
echo $n
echo $RANDOM
echo $(( 1 + RANDOM % 10 ))
echo $(( 1 + RANDOM % 20 ))
echo $(( 1 + RANDOM % 100 ))

----
help test
[ -d ~ ] --> It's important to add spaces to the insides of the brackets
echo $?
[ -d /bin/bash ]; echo $?
[ -d /bin ]; echo $?
[ "cat" = "dog" ]; echo $? --> The following symbols are used only by strings  >, >=, <, <= 
[ 1 = 1 ]; echo $?
[ 1 -lt 5 ]; echo $?
[ ! 1 -lt 5 ]; echo $?

----
[[  ]] --> This is called extended tests and give us extended tools not provided by regular test, say, []
[[ -d ~ && -a /bin/bash ]]; echo $?
[[ -d ~ || -a /bin/bashh ]]; echo $?
[[ -d ~ ]] && echo This runs if the statement inside of double brackets is true
ls && echo This runs if the statement inside of double brackets is true
true && echo This runs if the statement inside of double brackets is true
false && echo This runs if the statement inside of double brackets is true
[[ "cat" =~ c.* ]]; echo $?

----
echo -e "\a"
echo -e "Name\t\tNumber"; echo -e "Scott\t\t123"
echo -e "This text\nbreaks over\nthree lines"
echo -e "Ding\a"

----
echo "The results are: $(( 2 + 2 )) and $(( 3 / 1 ))"
printf "The results are: %d and %d\n" $(( 2 + 2 )) $(( 3 / 1 ))

----
Arrays

declare -a snacks=("apple" "banana" "orange")
echo ${snacks[2]}
snacks[5]="grapes"
snacks+=("mango")
echo ${snacks[@]}
for i in {0..6}; do echo "$i: ${snacks[$i]}"; done
declare -A office
office[city]="San Francisco"
office["building name"]="HQ West"
echo ${office["building name"]} is in ${office[city]}"
echo ${!office[@]} --> To acquire all keys
echo ${office[@]} --> To acquire all values

----
The execution of the commands returns a 0 or 1 as saw in the "comparison section". So, those can be used as conditions in if-statements. 

