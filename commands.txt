bash --version
echo $SHELL --> To see the main shell in my computer
history | less --> To see the content in an interactive way
history | wc --> To see the amount of lines, words and characterers in a file
cat commands.txt | wc -l
cat commands.txt | wc -w
cat commands.txt | wc -c

Piping is usually used with the following tools:
    grep, awk, sed, cut

Other editors that I could use --> EMACS or ED

----

What do 0,1, and 2 mean Bourne Shell?

0 --> Standard input (stdin)
1 --> Standard output (stdout)
2 --> Standart error (stderr)

----

ls > output.txt --> Truncate
ls >> output.txt --> Append

ls /notreal 1> output.txt 2> error.txt
ls /notreal 1>> output.txt 2>> error.txt

I can use too "ls /notreal 0> output.txt" but, it's a bit counterproductive, things doesn't work well here

When using ">" or ">>" the default number used on background is 1

cat < commands.txt
ls | cat

cat << EndOfText
This is
a multiline
bash command giver
EndOfText

----

Piping is used to send streams from one program to another

Redirection is used to send strems from one file to another

----
|
>
>>
1>
2>
1>>
2>>
<
<<

<< EndOfText
    "Commands"
EndOfText

----
Built-in functions

echo  --> Output something on the shell adding a jumpspace
printf  --> Output something on he shell without add a jumpspace
command echo  --> To execute external program version of a command (echo could be a built-in or an external program)
builtin echo  --> To execute the built-in program version of a command
command -V echo  --> To realize if the command is an external program or a built-in program (This is a built-in)
command -V df  --> To realize if the command is an external program or a built-in program (This is an external program)

The default is always the built-in programs

enable -n echo --> To disable the built-in form of a program as default. In this case, the external program will default to echo
enable -n  --> To see the whole list of disabled built-in commands
enable echo  --> To enable the built-in command echo as the default
help echo --> To see the manpages of a built-in command. Built-in commands have different manpages
help --> To see the builtins that bash provides

----

Bash Expansions and Substitutions:

~  --> Tilde expansion
{...}  --> Brace expansion
${...}  --> Parameter expansion
$(...)  --> Also `...`  --> Command expansion
$((...)) --> Also $[...]  --> Arithmetic expansion

----

Tilde Expansion  --> To save the user's HOME directory

echo ~  --> Too see what's user's home. It is not the "global" home
echo $HOME  --> To do exactlly the same as previous command
whoami  --> To see what's the user I'm using
echo ~- --> To see the previous directory I was in
echo $OLDPWD --> To do exactly the same as previous command

----

Brace Expansion  --> To express range of numbers or any other sequence shorter

echo /tmp/{one,two,three}/file.txt
    /tpm/one/file.txt /tpm/two/file.txt /tpm/three/file.txt

echo c{a,o,u}t
    cat cot cut

echo /tmp/{1..3}/file.txt
    /tmp/1/file.txt /tmp/2/file.txt /tmp/3/file.txt

echo {00..100}
    000 001 002 003 004 (more numbers) 097 098 099 100
    
echo {1..10}
echo {10..1}

echo {01..100}
echo {00001..10}

echo {100..00}

echo {a..z}
echo {Z..A}

echo {1..30..3}

echo {a..z..2}

touch file_{01..12}{a..d}
rm file_*

echo {cat,dog,fox}
echo {cat,dog,fox}_{1..5}

head -n1 {dir1,dir2,dir3}/lorem.txt

----

Parameter Expansion  --> To retreive the value of variables

a="Hello World World"
    echo $a  --> Retrieves the value of variable a. This is different to "echo a" because this "a" is not represented as a variable just a character.
        Hello World World
    echo ${a}  --> This is exactly the same as previous command
        Hello World World
    echo ${a:4}
        o World World
    echo ${a:1:12}
        ello World W
    echo ${a:6:3}
        Wor
    echo ${a/World/Everybody}  --> This is called Pattern Susbstitution
        Hello Everybody World
    echo ${a//World/Everybody}  --> This is called Pattern Susbstitution
        Hello Everybody Everybody
    echo ${a//o/_}  --> This is called Pattern Susbstitution
        Hell_ W_rld W_rld
    echo $a:1:12  --> Everything after the variable is gonna be interpreted as characters not as a Parameter Expansion. That's why the most of the times es important to add the {} to use the tools provided by Paremeter Substitution
        Hello World World:1:12

----

Command Expansion  --> To encapsulate commands inside another command

It is usally used with string manipulation tools like "echo" to extract a part of a command's output such as a:

    Path
    File size
    IP address
    So on

It is usually used with tools like

    grep
    awk
    cut

I can represent it as:
    $(...)  --> This is the most used
    `...`  --> This isn't the most used because is apparentely a bit confusing

uname -r

echo "The kernel is $(uname -r)."
echo "The kernel is `uname -r`."

echo "The python version is $(python3 -V)"
echo "The python version is `python3 -V`"

echo "Result: $(python3 -c 'print("Hello from Python!")')"
echo "Result: `python3 -c 'print("Hello from Python!")'`"

echo "Result: $(python3 -c 'print("Hello from Python!")' | tr [a-z] [A-Z])"
echo "Result: `python3 -c 'print("Hello from Python!")' | tr [a-z] [A-Z]`"

----

Arithmetic Expansion  --> It's similar to Parameter Expansions but this time it's used for Arithmetic Expressions

Older representation $[]

echo $((2+2))
echo $((3-2))
echo $((3*4))
echo $((4/5))
Bash can only calculate operations using integers

----

Combination of Parameter Expansion and Arithmetic Expansion

echo "Result: $(python3 -c 'print("Hello from Python!")') $((2+2))"
    Result: Hello from Python! 4

echo "Result: $(python3 -c 'print("Hello from Python!")') $((2+2))"  --> It returns exactly as previous command but it's using back ticks instead of dollar sign + parenthesis.
    Result: Hello from Python! 4

----

Bash Scripts Foundations  --> What to know before writing bash shell scripts

One-liners bash programs are useful when using it with aliases to use one alias to execute the whole set of commands separated by semicolon.

Ways to execute multi-liners bash programs:

    - bash file.sh

    - Including the shebang line as the first line (#!/usr/bin/env bash). This case is bash but it can be Python or Ruby or whatever interpreted scripting language (But I have to give privileges to the file using "chmod +x file.sh") (The code should be executed using the command "./file.sh").
        - The previous shebang finds the shell used by the environment, but there could be another shebang more directly, something like (The code should be executed using the command "./file.sh"):
            - #!/usr/bin/bash
        - I can also use in python code, the following (The code should be executed using the command "./file.sh"):
            - #!/usr/bin/python3
        - I can also execute .sh files prompting in the bash shell something like:
            - /usr/bin/bash file.sh
        - Or:
            - /usr/bin/env bash file.sh
        - I can also execute .py files prompting in the bash shell something like:
            - /usr/bin/python3 file.py

    - Running locally with ./file.sh or file if in the $PATH

    - I can also name the files without using the .sh

- I have to use the following tools if I need to set or unset certaing configurations made to the bash shell (change options for the shubshell):
    
    set
    shopt

----
embeddedWord="nice"
echo Hi $embeddedWord world!
echo "Hi $embeddedWord world!"
echo Hi \(big\) world. The kernel is $(uname -r)
echo 'Hi \(big\) world. The kernel is $(uname -r)' --> These are the strong quotes
echo "Hi \(big\) world. The kernel is $(uname -r)" --> More flexible
echo;echo "Ni hao!";echo
echo -n "Ni hao" --> Turns out the new line

----
_var=hi
_var="hi hi"
_var=7
echo $_var
declare -r _immutable_var=14
declare -l _lowercase_var="HELLO HELLO"
_lowercase_var="NI HAO NI HAO"
declare -u _uppercase_var="hi hi"
_uppercase_var="guten morgen"
declare -p
echo $USER

----
echo $(( (3+6)*12 - (2**7)  ))
a=3
((a+=3))
((a++))
((a--))
b=$a+1 --> Bash treats this as a string
declare -i b=3 --> To declare a variable to be used as an integer
b=$b+1 --> This isn't gonna give as an error
echo $((a++)) --> I coudl use it here
declare -i c
declare -i e=1
declare -i f=3
n=$(echo "scale=3; $e/$f" | bc)
echo $n
echo $RANDOM
echo $(( 1 + RANDOM % 10 ))
echo $(( 1 + RANDOM % 20 ))
echo $(( 1 + RANDOM % 100 ))

----
help test
[ -d ~ ] --> It's important to add spaces to the insides of the brackets
echo $?
[ -d /bin/bash ]; echo $?
[ -d /bin ]; echo $?
[ "cat" = "dog" ]; echo $? --> The following symbols are used only by strings  >, >=, <, <= 
[ 1 = 1 ]; echo $?
[ 1 -lt 5 ]; echo $?
[ ! 1 -lt 5 ]; echo $?

----
[[  ]] --> This is called extended tests and give us extended tools not provided by regular test, say, []
[[ -d ~ && -a /bin/bash ]]; echo $?
[[ -d ~ || -a /bin/bashh ]]; echo $?
[[ -d ~ ]] && echo This runs if the statement inside of double brackets is true
ls && echo This runs if the statement inside of double brackets is true
true && echo This runs if the statement inside of double brackets is true
false && echo This runs if the statement inside of double brackets is true
[[ "cat" =~ c.* ]]; echo $?

----
echo -e "\a"
echo -e "Name\t\tNumber"; echo -e "Scott\t\t123"
echo -e "This text\nbreaks over\nthree lines"
echo -e "Ding\a"

----
echo "The results are: $(( 2 + 2 )) and $(( 3 / 1 ))"
printf "The results are: %d and %d\n" $(( 2 + 2 )) $(( 3 / 1 ))

----
Arrays

declare -a snacks=("apple" "banana" "orange")
echo ${snacks[2]}
snacks[5]="grapes"
snacks+=("mango")
echo ${snacks[@]}
for i in {0..6}; do echo "$i: ${snacks[$i]}"; done
declare -A office
office[city]="San Francisco"
office["building name"]="HQ West"
echo ${office["building name"]} is in ${office[city]}"
echo ${!office[@]} --> To acquire all keys
echo ${office[@]} --> To acquire all values

----
The execution of the commands returns a 0 or 1 as saw in the "comparison section". So, those can be used as conditions in if-statements. 

